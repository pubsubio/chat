var net = require('net');
var common = require('common');
var crypto = require('crypto');
var parseURL = require('url').parse;
var createRouter = require('router').create;

var Parser = common.emitter(function() {
	this.buffer = '';
	this.start = 0;
	this.framing = false;
});

Parser.prototype.parse = function(data) {
	var index = -1;
	var last = 0;
	
	while ((index = data.indexOf(this.framing ? '\ufffd' : '\u0000', last)) > -1) {
		if (this.framing) {
			this.emit('message', this.buffer.substring(this.start)+data.substring(last, index));
			this.buffer = '';
		}
		
		this.start = last = index+1;
		this.framing = !this.framing;
	}
	if (this.framing && last <= data.length) {
		this.buffer += data;
	}
};

var PING_INTERVAL = 60*1000;

var JSONSocket = common.emitter(function(socket) {
	this.socket = socket;
	this.buffer = [];
	
	this._ping = null;
	
	socket.setEncoding('utf-8');
	socket.setTimeout(2*60*1000);
	
	var self = this;
	var parser = new Parser();
	
	parser.on('message', function(message) {
		if (message === 'ping') {
			self._write('pong');
			return;
		}
		if (message === 'pong') {
			return;
		}
		self.emit('message', JSON.parse(message));
	});
	
	if (socket.readyState === 'open') {
		this.send = this._send;
	} else {
		socket.on('connect', function() {
			self.send = self._send;
			while (self.buffer.length) {
				self._send(self.buffer.shift());
			}
			self.emit('open');
		});
	}
	
	var onclose = common.once(function() {
		clearInterval(self._ping);
		self.emit('close');
	});
	
	socket.on('end', function() {
		socket.destroy();
	});
	socket.on('timeout', function() {
		socket.destroy();
	});
	
	socket.on('error', onclose);
	socket.on('close', onclose);
	
	socket.on('data', function(data) {
		parser.parse(data);
	});
});

JSONSocket.prototype.send = function(data) {
	this.buffer.push(data);
};
JSONSocket.prototype.ping = function() {
	var self = this;
	
	this._ping = setInterval(function() {
		self._write('ping');
	}, PING_INTERVAL);
};

JSONSocket.prototype._send = function(data) {
	this._write(JSON.stringify(data));
};
JSONSocket.prototype._write = function(data) {
	this.socket.write('\u0000', 'binary');
	this.socket.write(data);
	this.socket.write('\uffff', 'binary');	
};

var normalize = function(host) {
	var matches = (host || 'localhost').match(/([^:]+):?(\d*)/).slice(1);
	
	return {
		host : matches[0],
		port : parseInt(matches[1] || '10547',10)
	};
};

exports.connect = function(host) {
	var host = normalize(host);
	var socket = net.createConnection(host.port,host.host);
	
	socket = new JSONSocket(socket);
	socket.ping();
	
	return socket;
};

exports.createServer = function(onsocket) {
	var server = net.createServer(function(socket) {
		onsocket(new JSONSocket(socket));
	});
	
	var that = {};
	
	that.listen = function(port, callback) {
		if (typeof port !== 'number') {
			callback = port;
			port = 10547;
		}
		server.listen(port, callback);
	};
	that.close = function(callback) {
		server.close(callback);
	};
	
	return that;
};

// Browser interface

var onwebsocket = function(callback) {	
	// TODO: add protocal 6
	var sign = function(request, head) {
		var md5 = crypto.createHash('md5');
		var k1 = request.headers['sec-websocket-key1'];
		var k2 = request.headers['sec-websocket-key2'];

		[k1, k2].forEach(function(k){
			var n = parseInt(k.replace(/[^\d]/g, ''), 10);
			var spaces = k.replace(/[^ ]/g, '').length;

			if (spaces === 0 || n % spaces !== 0){
				return null;
			}
			n /= spaces;
			md5.update(String.fromCharCode(
				n >> 24 & 0xFF,
				n >> 16 & 0xFF,
				n >> 8  & 0xFF,
				n       & 0xFF));
		});
		md5.update(head.toString('binary'));
		return md5.digest('binary');	
	};

	return function(request, connection, head) {
		connection.setNoDelay(true);	

		var sec = 'sec-websocket-key1' in request.headers ? 'Sec-' : '';
		var token = sec && sign(request, head);

		if (token === null) {
			connection.destroy();
			return;
		}

		var handshake = [
			'HTTP/1.1 101 Web Socket Protocol Handshake', 
			'Upgrade: WebSocket', 
			'Connection: Upgrade',
			sec + 'WebSocket-Origin: ' + request.headers.origin || 'null',
			sec + 'WebSocket-Location: ws://' + request.headers.host + (request.realUrl || request.url)
		].join('\r\n');

		connection.write(handshake + '\r\n\r\n' + token, 'binary');	
		callback(connection);
	};
};

var TIMEOUT = 15000;

var LongPoll = common.emitter(function() {
	this._chunk = '';
	this._buffer = [];
	this._reader = this._pusher;
	this._destroyed = false;
	this._timeout = setTimeout(this.destroy.bind(this), TIMEOUT);
});

LongPoll.prototype.send = function(message) {
	this._reader(null, JSON.stringify(message));
};
LongPoll.prototype.destroy = function() {
	if (this._destroyed) {
		return;
	}
	clearTimeout(this._timeout);
	
	this._destroyed = true;
	this._reader(new Error('socket destroyed'));
	this.emit('close');
};

LongPoll.prototype.read = function(fn) {
	var self = this;
	var buffer = this._buffer;

	if (buffer.length) {		
		this._buffer = [];
		fn(null, buffer.join('\n')+'\n');
		return;
	}
	
	clearTimeout(this._timeout);
	
	this._reader = function(err, data) {
		self._timeout = setTimeout(self.destroy.bind(self), TIMEOUT);
		self._reader = self._pusher;
		fn(err, data);
	};
};
LongPoll.prototype.write = function(messages) {
	var self = this;
	
	messages = (this._chunk + messages).split('\n');

	this._chunk = messages.pop();
	
	messages.forEach(function(message) {
		if (message === 'ping') {
			self._reader(null, 'pong');
			return;
		}
		message = JSON.parse(message);
		self.emit('message', message);
	});
};

LongPoll.prototype._pusher = function(err, data) {
	if (err) {
		return;
	}
	this._buffer.push(data);
};

exports.listen = function(router, onsocket) {
	if (typeof router === 'number') {
		var port = router;
		
		router = exports.listen(createRouter(), onsocket);
		router.listen(port);
		
		return router;
	}
	var polls = {};

	router = createRouter(router);
	
	router.upgrade('/json-sockets', onwebsocket(function(connection) {
		onsocket(new JSONSocket(connection));
	}));

	var responder = function(query, response) {
		if (query.callback) {
			return function(status, data) {
				response.writeHead(200, {'content-type':'application/javascript'});
				response.end(query.callback+'('+JSON.stringify(data)+');');
			};
		}
		return function(status, data) {
			response.writeHead(status, {'access-control-allow-origin':'*', 'content-type':'text/plain; charset=utf-8'});
			response.end(data);
		};
	};

	router.get('/json-sockets/create', function(request, response) {
		var query = parseURL(request.url, true).query;
		var id = Math.random().toFixed(20).substring(2);	
		var lp = polls[id] = new LongPoll();
		var respond = responder(query, response);

		lp.on('close', function() {
			delete polls[id];
		});

		onsocket(lp);

		respond(200, id);
	});

	router.get('/json-sockets/read', function(request, response) {
		var query = parseURL(request.url, true).query;
		var socket = polls[query.id];

		var respond = responder(query, response);
		var onerror = function() {
			respond(404, '');
		};

		if (!socket) {
			onerror();
			return;
		}

		request.on('close', function() {
			socket.destroy();
		});

		socket.read(common.fork(onerror, function(data) {
			respond(200, data);
		}));
	});

	router.get('/json-sockets/write', function(request, response) {
		var query = parseURL(request.url, true).query;
		var respond = responder(query, response);
		var socket = polls[query.id];
		
		if (!socket) {
			respond(404, '');
			return;
		}
		
		socket.write(query.post);
		respond(200, 'ack');
	});
	router.post('/json-sockets/write', function(request, response) {
		var query = parseURL(request.url, true).query;
		var socket = polls[query.id];

		var onerror = function() {
			request.connection.destroy();
		};

		if (!socket) {
			onerror();
			return;
		}
		var buf = '';

		request.setEncoding('utf-8');
		request.on('data', function(data) {
			buf += data;
		});
		request.on('end', function() {
			if (polls[query.id]) {
				socket.write(buf);			
			}
			response.writeHead(200, {'access-control-allow-origin':'*'});
			response.end('ack');		
		});
	});
	
	return router;
};